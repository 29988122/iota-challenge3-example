Of course. Here is a professional, GitHub-ready `README.md` file for this project, written in English.

---

# IOTA Move CTF - Challenge #3 Solver (Rust)

This repository contains a Rust-based solution for **Challenge #3 ("Mint Coin")** of the IOTA Move CTF. The program interacts directly with the IOTA Testnet using the official `iota-sdk` for Rust to solve the challenge by minting, merging, and splitting custom Move `Coin` objects.

## Table of Contents

- [Challenge Overview](#challenge-overview)
- [Solution Strategy](#solution-strategy)
- [Prerequisites](#prerequisites)
- [Setup and Configuration](#setup-and-configuration)
  - [1. Clone the Repository](#1-clone-the-repository)
  - [2. Configure Keystore](#2-configure-keystore)
  - [3. Fund Your Wallet](#3-fund-your-wallet)
- [How to Run](#how-to-run)
- [Code Breakdown](#code-breakdown)
  - [Part 1: Initialization](#part-1-initialization)
  - [Part 2: Transaction 1 - Minting Coins](#part-2-transaction-1---minting-coins)
  - [Part 3: State Query](#part-3-state-query)
  - [Part 4: Transaction 2 - Merge, Split, and Get Flag](#part-4-transaction-2---merge-split-and-get-flag)
- [Important Notes](#important-notes)

## Challenge Overview

The goal of Challenge #3 is to successfully call the `get_flag` function in the deployed `mintcoin` Move module. A review of the source code reveals a critical requirement: the function will only succeed if it is called with a `Coin<MINTCOIN>` object whose value is **exactly 5**.

However, the provided `mint_coin` function only allows us to mint coins with a value of 2, making it impossible to directly create a coin of value 5.

## Solution Strategy

This solver adopts a multi-transaction approach to overcome the challenge:

1.  **Transaction 1: Minting Phase**
    -   A single programmable transaction is constructed to call the `mint_coin` function three times.
    -   This results in three separate `Coin<MINTCOIN>` objects, each with a value of 2, being created and sent to our wallet. The total value is 6.

2.  **State Query Phase**
    -   After the first transaction is confirmed, the program queries the network to find the `Object ID`s of the three newly minted coins in our wallet.

3.  **Transaction 2: Logic Phase**
    -   A second, more complex programmable transaction is constructed to perform the core logic in a single, atomic operation:
        -   **Merge:** The three coins (value 2 each) are merged into a single coin object with a total value of 6.
        -   **Split:** The merged coin of value 6 is split, creating a new coin with the target value of 5.
        -   **Get Flag:** The `get_flag` function is immediately called with the required `Counter` object and our newly created coin of value 5.

This strategy ensures that all required conditions are met, leading to the successful creation of the `Flag` object.

## Prerequisites

-   [Rust](https://www.rust-lang.org/tools/install) toolchain (`rustc`, `cargo`).
-   An IOTA wallet managed by `iota-client-cli`. If you don't have one, please initialize it first:
    ```bash
    iota-client-cli init
    ```

## Setup and Configuration

### 1. Clone the Repository

```bash
git clone <repository-url>
cd <repository-directory>
```

### 2. Configure Keystore

This program reads your wallet's private key from the default `iota.keystore` file generated by `iota-client-cli`. Ensure this file exists at the following path:

-   **Linux/macOS:** `~/.iota/iota_config/iota.keystore`
-   **Windows:** `C:\Users\<YourUser>\.iota\iota_config\iota.keystore`

The program will automatically locate this file.

### 3. Fund Your Wallet

Your wallet address must hold some IOTA Testnet tokens to pay for transaction gas fees. You can obtain free tokens from the official IOTA Faucet:

[https://faucet.testnet.iotaledger.net/](https://faucet.testnet.iotaledger.net/)

## How to Run

Execute the program using Cargo. It will compile and run the solver.

```bash
cargo run
```

The program will print detailed logs for each step, including connecting to the network, signing transactions, and broadcasting them. Upon successful completion of the second transaction, the console output will display the final transaction effects, which will include the `Object ID` of the newly created `Flag` object.

## Code Breakdown

The `src/main.rs` file is structured into several logical parts:

### Part 1: Initialization

-   Sets up constants for the required contract `Object ID`s.
-   Establishes a connection to the IOTA Testnet JSON-RPC endpoint.
-   Loads the user's keystore to enable transaction signing.
-   Fetches the user's wallet address and a `Coin` object to use for paying gas fees.

### Part 2: Transaction 1 - Minting Coins

-   A `ProgrammableTransactionBuilder` is used to create a transaction that calls the `mint_coin` function three times.
-   The transaction is signed and broadcast to the network.

### Part 3: State Query

-   The program pauses briefly to allow for network synchronization.
-   It then queries the network for all `Coin<MINTCOIN>` objects owned by the user's address to retrieve their `Object ID`s.

### Part 4: Transaction 2 - Merge, Split, and Get Flag

-   A second `ProgrammableTransactionBuilder` assembles the core logic.
-   It takes the `Object ID`s from the previous step as inputs.
-   It chains several Move calls: `merge`, `merge` again, `split`, and finally `get_flag`.
-   This final transaction is signed and broadcast, completing the challenge.

## Important Notes

-   **Shared Object Versions:** This code uses hardcoded `initial_shared_version` values for the `TreasuryCap` and `Counter` objects. In a real-world scenario, these versions must be queried from the network right before building the transaction to ensure they are up-to-date. Using a stale version will cause the transaction to fail.
-   **API Usage:** The code uses a lower-level API (`quorum_driver_api`, `ProgrammableTransactionBuilder`) for fine-grained control over transaction construction. This demonstrates an advanced usage pattern of the `iota-sdk`.